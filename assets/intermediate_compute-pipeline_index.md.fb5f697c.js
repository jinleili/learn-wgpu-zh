import{_ as l,c as o,b as s,a as e,o as r,r as n}from"./app.5f0be10f.js";const c="/learn-wgpu-zh/assets/workgroups.e0cdd028.png",t="/learn-wgpu-zh/assets/global_invocation_id.88d705bb.png",D="/learn-wgpu-zh/assets/local_invocation_id.2af66c96.png",_=JSON.parse('{"title":"计算管线","description":"","frontmatter":{},"headers":[],"relativePath":"intermediate/compute-pipeline/index.md","lastUpdated":1670733890000}'),F={name:"intermediate/compute-pipeline/index.md"},y=e(`<h1 id="计算管线" tabindex="-1">计算管线 <a class="header-anchor" href="#计算管线" aria-hidden="true">#</a></h1><p><strong>计算管线</strong>（<code>ComputePipeline</code>）是 WebGPU 中控制<strong>计算着色器</strong>（Compute Shader）阶段的管线。</p><p>计算管线适用于各种 GPU 通用计算场景，这是 WebGL 所不具备的。我们通过绑定的<strong>存储缓冲区</strong>（Storage Buffer）及<strong>存储纹理</strong>（Storage Texture）来获得计算输出。</p><h2 id="创建一个计算管线" tabindex="-1">创建一个计算管线 <a class="header-anchor" href="#创建一个计算管线" aria-hidden="true">#</a></h2><p>计算管线的创建相比于<strong>渲染管线</strong>简单得多，甚至我们都不需要显式创建并指定<strong>绑定组布局</strong>（BindGroupLayout）：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> compute_shader </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> device</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create_shader_module</span><span style="color:#89DDFF;">(...);</span></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> compute_pipeline </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> device</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create_compute_pipeline</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#FFCB6B;">wgpu</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">ComputePipelineDescriptor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">        layout</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">None</span><span style="color:#89DDFF;">,</span><span style="color:#676E95;"> // 此处使用了隐式布局</span></span>
<span class="line"><span style="color:#A6ACCD;">        module</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">compute_shader</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        entry_point</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">cs_main</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">        label</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">None</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><div class="warning"><p>使用隐式绑定组布局有一个小小的局限：绑定的每个资源必须在<strong>入口点</strong>（Entry Point）中有被访问到。如果有没被访问的绑定资源，就必须显式指定布局。</p></div><h2 id="使用存储缓冲区与存储纹理" tabindex="-1">使用存储缓冲区与存储纹理 <a class="header-anchor" href="#使用存储缓冲区与存储纹理" aria-hidden="true">#</a></h2><p><strong>存储缓冲区</strong>与<strong>存储纹理</strong>都是 WGSL 中的资源类型。</p><p>而我们在 wgpu 中创建及绑定它们时，与其它缓冲区及纹理的创建是一样的，只需要在 <code>usage</code> 字段中标记出用途：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> buf </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> device</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create_buffer_init</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#FFCB6B;">wgpu</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">util</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">BufferInitDescriptor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;">        // ...</span></span>
<span class="line"><span style="color:#676E95;">        // VERTEX | STORAGE 表示此缓冲区可以做为顶点缓冲区以及存储缓冲区来使用</span></span>
<span class="line"><span style="color:#A6ACCD;">        usage</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BufferUsages</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">VERTEX </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">BufferUsages</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">STORAGE</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">});</span></span>
<span class="line"></span>
<span class="line"><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> tex </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> app</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">device</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">create_texture</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#FFCB6B;">wgpu</span><span style="color:#89DDFF;">::</span><span style="color:#FFCB6B;">TextureDescriptor</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;">        // ...</span></span>
<span class="line"><span style="color:#676E95;">        // TEXTURE_BINDING | STORAGE_BINDING 表示此纹理可以做为采样纹理以及存储纹理来使用</span></span>
<span class="line"><span style="color:#A6ACCD;">        usage</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TextureUsages</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">TEXTURE_BINDING </span><span style="color:#89DDFF;">|</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">TextureUsages</span><span style="color:#89DDFF;">::</span><span style="color:#A6ACCD;">STORAGE_BINDING</span><span style="color:#89DDFF;">,</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">});</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>在 WGSL 中，<strong>存储缓冲区</strong>与<strong>存储纹理</strong>有一些使用上的区别：</p><ul><li><strong>存储缓冲区</strong>：默认访问模式是<strong>只读</strong>，可以通过 <code>read_write</code> 声明为可读可写, 读写操作类似于数组的访问与赋值;</li><li><strong>存储纹理</strong>：默认访问模式是<strong>只写</strong>，而且在 Web 端只能用<strong>只写</strong>模式，在 Native 端我们可以使用 <code>TEXTURE_ADAPTER_SPECIFIC_FORMAT_FEATURES</code> feature 来打开可读可写的访问模式。还有，存储纹理必须明确声明纹素的格式，且不支持带 <code>Srgb</code> 后缀的格式。从这里可以查阅到所有受支持的格式： <a href="https://gpuweb.github.io/gpuweb/wgsl/#storage-texel-formats" target="_blank" rel="noreferrer">WGSL 标准：存储纹素格式</a></li></ul><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">Particle</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  pos </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">f32</span><span style="color:#89DDFF;">&gt;,</span></span>
<span class="line"><span style="color:#A6ACCD;">  vel </span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">f32</span><span style="color:#89DDFF;">&gt;,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#676E95;">// 存储缓冲区</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">binding</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> var</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">storage</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> read_write</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> particles</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> array</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">Particle</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">binding</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> var from_tex</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> texture_2d</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">f32</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#676E95;">// 存储纹理</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">binding</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> var to_tex</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> texture_storage_2d</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">rgba8unorm</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> write</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#A6ACCD;">compute </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">workgroup_size</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cs_main</span><span style="color:#89DDFF;">(@</span><span style="color:#82AAFF;">builtin</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">global_invocation_id</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> global_id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec3</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">u32</span><span style="color:#89DDFF;">&gt;)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> uv </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">i32</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">global_id</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">xy</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;">    // 读取存储缓冲区</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> particle </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> particles</span><span style="color:#89DDFF;">[</span><span style="color:#A6ACCD;">vu</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">*</span><span style="color:#A6ACCD;"> uv</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">y</span><span style="color:#89DDFF;">];</span></span>
<span class="line"></span>
<span class="line"><span style="color:#A6ACCD;">    var texel</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec4</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">f32</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"><span style="color:#676E95;">    // ...</span></span>
<span class="line"><span style="color:#676E95;">    // 写入纹素数据到存储纹理</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#82AAFF;">textureStore</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">to_tex</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> uv</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> texel</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="计算通道" tabindex="-1">计算通道 <a class="header-anchor" href="#计算通道" aria-hidden="true">#</a></h2><p>与创建<strong>渲染通道</strong>类似，我们需要使用 <code>encoder</code> 来创建<strong>计算通道</strong>（<code>ComputePass</code>），然后用<strong>计算通道</strong>来编码所有的计算<strong>命令</strong>：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// let encoder = ...</span></span>
<span class="line"><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">mut</span><span style="color:#A6ACCD;"> cpass </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> encoder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">begin_compute_pass</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#FFCB6B;">ComputePassDescriptor</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">default</span><span style="color:#89DDFF;">());</span></span>
<span class="line"><span style="color:#A6ACCD;">    cpass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set_pipeline</span><span style="color:#89DDFF;">(&amp;</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">compute_pipeline</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#A6ACCD;">    cpass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">set_bind_group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">bind_group</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">&amp;[]);</span></span>
<span class="line"><span style="color:#A6ACCD;">    cpass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">dispatch_workgroups</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">workgroup_count</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> self</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">workgroup_count</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"><span style="color:#A6ACCD;">queue</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">submit</span><span style="color:#89DDFF;">(</span><span style="color:#FFCB6B;">iter</span><span style="color:#89DDFF;">::</span><span style="color:#82AAFF;">once</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">encoder</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">finish</span><span style="color:#89DDFF;">()));</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在<a href="./../../beginner/tutorial2-surface/#渲染">展示平面</a>章节已讲解过 <code>{}</code> 开辟块空间的用途，这里就不再赘述。</p><p><code>dispatch_workgroups()</code> 就是调度计算任务的命令，接受 3 个 <code>u32</code> 类型的值做为参数。这些参数具体是什么意思呢？那就要说到计算管线里最重要的一个概念了：</p><h2 id="工作组" tabindex="-1">工作组 <a class="header-anchor" href="#工作组" aria-hidden="true">#</a></h2><p>GPU 通过同时运行大量线程来实现并行处理的能力，而<strong>工作组</strong>（Workgroup）就是用于指定 GPU 如何组织这些线程。<br> 一个<strong>工作组</strong>实质上就是一组调用，同一工作组中的线程同时分别执行一个<strong>计算着色器</strong>实例，并共享对工作组地址空间中着色器变量的访问。计算着色器通常被设计成线程相互独立运行，但线程在其工作组上进行协作也很常见。</p><p>可以将<strong>工作组</strong>理解为一个三维网格，网格中的每个点就代表一个线程。在图像处理中，网格通常是一个二维的线程矩阵（二维就是其中一个维度为 1 的特殊三维形式），代表整个图像，每个线程对应于正在处理的图像的一个像素。</p><p>我们通过（x, y, z）三个维度来声明计算着色器的<strong>工作组</strong>大小，每个维度上的默认值都是 1：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">workgroup_size</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">)</span><span style="color:#676E95;"> // x = 32, y = 16, z = 1</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>下图显示了正在被着色器处理的图像如何被划分为工作组，以及每个工作组是如何由单个线程组成：</p><p><img src="`+c+'" alt="工作组网格"></p><p>那么，线程与工作组在计算着色器网格中的位置是如何被标识的呢？</p><h3 id="内建输入量" tabindex="-1">内建输入量 <a class="header-anchor" href="#内建输入量" aria-hidden="true">#</a></h3><p>WGSL 计算着色器有 5 个<strong>内建输入量</strong>（Buit-in Input Values）用于标识当前线程及工作组：</p><ul><li><code>global_invocation_id</code>：当前线程在计算着色器网格中的全局三维坐标;</li><li><code>local_invocation_id</code>：当前线程在所处的工作组中的局部三维坐标;</li><li><code>local_invocation_index</code>：当前线程在所处的工作组中的线性化索引;</li><li><code>workgroup_id</code>：当前工作组在工作组网格中的三维坐标;</li><li><code>num_workgroups</code>：当前<strong>调度</strong>（dispatch）的工作组维度量;</li></ul><p>最常用的是前三个<strong>内建输入量</strong>。</p><p>例如，给定一个由 <code>16 * 16 * 1</code> 个线程组成的网格，将其划分为 <code>2 * 4 * 1</code> 个工作组，<code>8 * 4 * 1</code> 个线程。 那么:</p><ul><li>一个线程在网格中的 <code>global_invocation_id</code> 全局三维坐标是 <code>(9, 10)</code>（左图）;</li><li>此线程在所处工作组中的 <code>local_invocation_id</code> 局部三维坐标是 <code>(1, 2)</code>， <code>local_invocation_index</code> 线性化索引是 <code>17</code>（右图）;</li><li>所处工作组在工作组网格中的 <code>workgroup_id</code> 三维坐标就是 <code>(1, 2)</code> （右图的蓝绿色块）：</li></ul><div style="display:flex;"><div><img src="'+t+'" alt="global_invocation_id"></div><div style="width:20px;"></div><div><img src="'+D+`" alt="local_invocation_id"></div></div><p>这些内建输入量在着色器中具体如何使用呢？下边的着色器中演示了如何直接通过 <code>global_invocation_id</code> 来获取纹素的坐标：</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#C792EA;">struct</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UniformParams</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  img_size</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">i32</span><span style="color:#89DDFF;">&gt;,</span></span>
<span class="line"><span style="color:#A6ACCD;">  uv_offset</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">i32</span><span style="color:#89DDFF;">&gt;,</span></span>
<span class="line"><span style="color:#89DDFF;">};</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">binding</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> var</span><span style="color:#89DDFF;">&lt;</span><span style="color:#A6ACCD;">uniform</span><span style="color:#89DDFF;">&gt;</span><span style="color:#A6ACCD;"> params</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#FFCB6B;">UniformParams</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">group</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">binding</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> var from_tex</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> texture_2d</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">f32</span><span style="color:#89DDFF;">&gt;;</span></span>
<span class="line"></span>
<span class="line"><span style="color:#89DDFF;">@</span><span style="color:#A6ACCD;">compute </span><span style="color:#89DDFF;">@</span><span style="color:#82AAFF;">workgroup_size</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#F78C6C;">fn</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">cs_main</span><span style="color:#89DDFF;">(@</span><span style="color:#82AAFF;">builtin</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">global_invocation_id</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> global_id</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> vec3</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">u32</span><span style="color:#89DDFF;">&gt;)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#676E95;">  // 纹素（图片的像素）坐标</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#C792EA;">let</span><span style="color:#A6ACCD;"> uv </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> vec2</span><span style="color:#89DDFF;">&lt;</span><span style="color:#FFCB6B;">i32</span><span style="color:#89DDFF;">&gt;(</span><span style="color:#A6ACCD;">global_id</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">xy</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#676E95;">  // 判断当前坐标是否超出了纹素坐标范围</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">if</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">uv</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">&gt;=</span><span style="color:#A6ACCD;"> params</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">img_size</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">x </span><span style="color:#89DDFF;">||</span><span style="color:#A6ACCD;"> uv</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">y </span><span style="color:#89DDFF;">&gt;=</span><span style="color:#A6ACCD;"> params</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">img_size</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">y</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">    </span><span style="color:#89DDFF;">return</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#89DDFF;">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#676E95;">  // 从纹理图像中读取纹素</span></span>
<span class="line"><span style="color:#A6ACCD;">  var texel </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">textureLoad</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">from_tex</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> uv</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">)</span></span>
<span class="line"><span style="color:#676E95;">  // ...</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><div class="warn"><p>使用计算着色器需要注意避免坐标越界问题，因为通常纹理图像的分辨率与我们的<strong>工作组</strong>大小不是整除关系。</p></div><h3 id="确定工作组大小与数量" tabindex="-1">确定工作组大小与数量 <a class="header-anchor" href="#确定工作组大小与数量" aria-hidden="true">#</a></h3><p><strong>工作组</strong>的最佳大小（指 x, y, z 三个维度的大小）并没有固定的值，需要结合实际使用场景来确定，而且能支持的最大值还与目标硬件有关。</p><p>我们从 <a href="https://gpuweb.github.io/gpuweb/#limits" target="_blank" rel="noreferrer">adapter.limits()</a> 里，能获取到当前设备支持的最大工作组大小 <code>(maxComputeWorkgroupSizeX，maxComputeWorkgroupSizeY，maxComputeWorkgroupSizeZ)</code>，它们的默认值分别为 <code>(256, 256, 64)</code>。</p><div class="warn"><p>这三个维度的最大值容易让人误解，以为可以在计算着色器中设置 <code>@workgroup_size(256, 256, 64)</code>。</p><p>事实上 WebGPU spec 的验证规则是：<code>x * y * z &lt;= max(x, max(y, z))</code>, 也就是说，设置的 <code>@workgroup_size</code> 三个维度的乘积不能大于 <code>maxComputeWorkgroupSizeX，Y，Z</code> 三个维度中的最大值。</p></div><p>通常，当只需要在计算着色器中操作存储缓冲区时，使用一维工作组 <code>@workgroup_size(x)</code> 是合适的, y、z 维度保持默认值 1; 当需要操作<strong>纹理</strong>，使用二维或三维工作组 <code>@workgroup_size(x，y)</code> 会更便利。</p><p>现在我们可以来回答开头的问题了：<br></p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#A6ACCD;">cpass</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">dispatch_workgroups</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;">workgroup_count</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">0</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> workgroup_count</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> workgroup_count</span><span style="color:#89DDFF;">.</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br></div></div><p>上面计算通道的<strong>调度</strong>命令接收的参数具体是什么意思呢？</p><p>它们就是工作组网格的 3 个维度量。<br> 以 <code>1000 * 768</code> 个线程组成的网格为例，假设工作组大小为<code>@workgroup_size(32，16)</code>，那么:</p><div class="language-rust line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki"><code><span class="line"><span style="color:#676E95;">// 计算维度值并向上取整</span></span>
<span class="line"><span style="color:#A6ACCD;">workgroup_count </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">((</span><span style="color:#F78C6C;">1000</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">32</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">32</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">768</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">+</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">16</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">-</span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">))</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">/</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">16</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">1</span><span style="color:#89DDFF;">);</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h2 id="cpu-端读取计算管线输出" tabindex="-1">CPU 端读取计算管线输出 <a class="header-anchor" href="#cpu-端读取计算管线输出" aria-hidden="true">#</a></h2><p>在<a href="./../../showcase/windowless/#从缓冲区中读取数据">案例展示/离屏渲染</a>章节已讲解过如何从缓冲区中读取数据，存储纹理的读取也是一样的，这里不再赘述。</p><h2 id="实战-实现高斯模糊" tabindex="-1">实战：实现高斯模糊 <a class="header-anchor" href="#实战-实现高斯模糊" aria-hidden="true">#</a></h2><p>要掌握 WebGPU 计算管线，核心内容就是上边讲解的 “使用存储缓冲区与存储纹理” 及 “工作组”，某个具体实现的着色器逻辑代码并不重要，因为它们与顶点及片元着色器代码没有太大的区别。</p><p>点击下方的<strong>查看源码</strong>就能看到所有实现代码。如对图片模糊算法的细节感兴趣，可以查看<a href="https://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html" target="_blank" rel="noreferrer">这里</a></p><h2 id="运行示例代码" tabindex="-1">运行示例代码 <a class="header-anchor" href="#运行示例代码" aria-hidden="true">#</a></h2><p><em>此示例目前只能在桌面端及 Chrome Canary 浏览器中运行！使用隐式绑定组布局目前在 Firefox Nightly 上有 bug: <span style="color:gray;">Uncaught (in promise) TypeError: GPUDevice.createComputePipeline: &#39;layout&#39; member of GPUPipelineDescriptorBase is not an object.</span></em></p>`,54);function i(C,A,u,d,b,g){const a=n("WasmExample"),p=n("AutoGithubLink");return r(),o("div",null,[y,s(a,{example:"compute_pipeline"}),s(p)])}const h=l(F,[["render",i]]);export{_ as __pageData,h as default};
