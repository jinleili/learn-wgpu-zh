import{_ as s,c as a,o as e,V as i}from"./chunks/framework.NhSu_boB.js";const t="/learn-wgpu-zh/assets/create.PI67xtCk.png",n="/learn-wgpu-zh/assets/template.ZaQEvDur.png",r="/learn-wgpu-zh/assets/name.E7OVs5to.png",l="/learn-wgpu-zh/assets/project.OJieJOtf.png",p="/learn-wgpu-zh/assets/option.tgsWiNAn.png",o="/learn-wgpu-zh/assets/info.zIhwR3lv.png",d="/learn-wgpu-zh/assets/triangle.swPHx-oi.png",h="/learn-wgpu-zh/assets/run.anexA9XQ.png",c="/learn-wgpu-zh/assets/result.Ny0pk3iA.png",g="/learn-wgpu-zh/assets/fps.KHtAZo6h.png",k="/learn-wgpu-zh/assets/capture.UPiFxBju.png",u="/learn-wgpu-zh/assets/debug_navigator.H_YJMyMQ.png",m="/learn-wgpu-zh/assets/buffer_data.6SFbM26w.png",D=JSON.parse('{"title":"使用 Xcode 调试 wgpu 程序","description":"","frontmatter":{},"headers":[],"relativePath":"integration-and-debugging/xcode/index.md","filePath":"integration-and-debugging/xcode/index.md","lastUpdated":1718847047000}'),E={name:"integration-and-debugging/xcode/index.md"},b=i('<h1 id="使用-xcode-调试-wgpu-程序" tabindex="-1">使用 Xcode 调试 wgpu 程序 <a class="header-anchor" href="#使用-xcode-调试-wgpu-程序" aria-label="Permalink to &quot;使用 Xcode 调试 wgpu 程序&quot;">​</a></h1><h2 id="xcode-与-metal" tabindex="-1">Xcode 与 Metal <a class="header-anchor" href="#xcode-与-metal" aria-label="Permalink to &quot;Xcode 与 Metal&quot;">​</a></h2><p><strong>Xcode</strong> 是苹果官方提供的运行在 macOS 系统上的 <strong>IDE</strong>，它提供了一整套工具来方便为苹果设备（比如，iPad、iPhone、Mac 等等）创建、测试、优化 App 并最终发布到 App Store。Xcode 是免费的，如果你使用的是 macOS 系统，就可以从 <a href="https://apps.apple.com/cn/app/xcode/id497799835?mt=12" target="_blank" rel="noreferrer">App Store</a> 上下载安装。</p><p><strong>Metal</strong> 是 wgpu 在苹果平台上使用的图形后端，Metal <strong>框架</strong>（Framework）通过提供低开销的底层 GPU 编程 API、图形和计算管线之间的紧密集成以及一套强大的 GPU 分析和调试工具，为苹果平台上的图形硬件加速提供动力。</p><p>2014 年，苹果在<strong>全球开发者大会</strong> (WWDC) 上宣布为 iOS 推出全新的 Metal 框架， 一年后的 WWDC 2015，苹果宣布了 macOS 上也将支持 Metal，随后是 watchOS 和 tvOS。 随着 Metal API 的不断发展，在 WWDC 2017 上推出了新版本，<strong>Metal 2</strong>。它增加了对虚拟现实 (VR)、增强现实 (AR) 和机器学习 (ML) 的支持，以及其它许多新功能.</p><p>今年（WWDC 2022）推出的 <strong>Metal 3</strong>，引入了更为强大的功能，能帮助游戏和专业应用程序充分挖掘苹果芯片的潜力：借助高性能放大和<strong>抗锯齿</strong>（anti-aliasing）功能，能在更短的时间内渲染高分辨率的图形; 使用异步 I/O 将资源数据直接从存储优化流式传输到 Metal 纹理和缓冲区，能更快地加载资源; 新的<strong>光线追踪</strong>（Metal Ray Tracing）构建加速结构所花费的 GPU 时间更少，可以通过将<strong>剔除</strong>（Culling）工作转移到 GPU 以减少 CPU 开销，并且通过直接访问原始数据来优化光线求交和着色; 还有机器学习加速及新的<strong>网格着色器</strong>（Mesh Shader）等等。</p><h2 id="创建调试项目" tabindex="-1">创建调试项目 <a class="header-anchor" href="#创建调试项目" aria-label="Permalink to &quot;创建调试项目&quot;">​</a></h2><p>首先，我们打开 Xcode，使用菜单或启动对话框中的 <code>Create a new Xcode project</code> 来创建一个新项目（左图），然后单击 <code>Other</code> 选项卡, 选中<strong>外部构建系统</strong>（External Build System）作为项目模板（右图）:</p><div style="display:flex;"><div><img src="'+t+'" alt="创建一个新的 Xcode 项目"></div><div style="width:20px;"></div><div><img src="'+n+'" alt="选择项目模板"></div></div><p>然后，在<strong>构建工具</strong>（Build Tool）字段中填入要使用的构建工具，Xcode 在运行项目时，将会调用此处设置的构建工具。 如果希望 Xcode 运行 cargo 构建命令，就可以填写 cargo 在你的 macOS 上的安装路径（默认的路径是 <code>${HOME}/.cargo/bin/cargo</code>），也可以留空来表示跳过构建步骤，以避免 Xcode 为我们构建项目。</p><p>其余的字段实际上对我们来说并不重要，因此可以随意填，但<strong>产品名称</strong>（Product Name）字段还是尽量填一个有意义的名称吧：</p><img src="'+r+'" alt="构建工具设置"><h2 id="编辑-scheme" tabindex="-1">编辑 Scheme <a class="header-anchor" href="#编辑-scheme" aria-label="Permalink to &quot;编辑 Scheme&quot;">​</a></h2><p>接着编辑项目的<strong>方案</strong>（Scheme）来启用 Metal 的 GPU <strong>帧捕获</strong>（Frame Capture）及 <strong>接口验证</strong>（API Validation）工具集。 通常，如果 Xcode 项目里的代码调用了 Metal 框架或任何其他使用了 Metal API 的框架，Xcode 会自动启用 GPU 帧捕获 和 Metal 接口验证，但我们的这个项目使用的是<strong>外部构建系统</strong>（External Build System），只能手动设置。</p><p>手动设置其实非常简单：</p><p>1，单击项目名称，然后单击 <code>Edit Scheme</code>（左图）（或者，从顶部菜单栏上选择 <code>Product</code> -&gt; <code>Scheme</code> -&gt; <code>Edit Scheme</code>）;</p><p>2，在弹出的<strong>方案</strong>功能面板中选中左边栏的 <code>Run</code>，将右边的功能配置表切换至 <code>Options</code> 选项卡，设置 <code>GPU Frame Capture</code> 栏为 <code>Metal</code> 来启用 GPU 帧捕获（右图）;</p><div class="note"><h5 id="gpu-frame-capture-栏三个选项的详细说明" tabindex="-1"><code>GPU Frame Capture</code> 栏三个选项的详细说明： <a class="header-anchor" href="#gpu-frame-capture-栏三个选项的详细说明" aria-label="Permalink to &quot;`GPU Frame Capture` 栏三个选项的详细说明：&quot;">​</a></h5><ul><li>Automatically：自动捕获项目中的 Metal 或 OpenGL ES API 使用情况。如果项目未链接到 Metal 或 OpenGL ES 框架，则 <code>Capture GPU Frame</code> 按钮不会显示在调试栏中。如果项目同时使用 Metal 和 OpenGL ES API，则可以单击并按住 <code>Capture GPU Frame</code> 按钮来选择要捕获的 API;</li><li>Metal：仅捕获项目中的 Metal API 使用情况;</li><li>Disabled：禁用 GPU 帧捕获功能;</li></ul></div><div style="display:flex;"><div><img src="'+l+'" alt="Edit Scheme"></div><div style="width:20px;"></div><div><img src="'+p+'" alt="GPU frame capture"></div></div><p>3，在 <code>Info</code> 选项卡下的 <code>executable</code> 栏（左图），我们来指定要运行的可执行文件：单击可选项里的 <code>Other</code>，然后在目标目录中找到由 cargo 创建的二进制文件（右图）。</p><div style="display:flex;"><div><img src="'+o+'" alt="Info 选项卡"></div><div style="width:20px;"></div><div><img src="'+d+'"></div></div><div class="note"><h5 id="如何找到-cargo-创建的二进制可执行文件" tabindex="-1">如何找到 cargo 创建的二进制可执行文件？ <a class="header-anchor" href="#如何找到-cargo-创建的二进制可执行文件" aria-label="Permalink to &quot;如何找到 cargo 创建的二进制可执行文件？&quot;">​</a></h5><p>我们以<a href="./../../beginner/tutorial3-pipeline/">管线</a>教程的示例代码为例，先在项目根目录（learn-wgpu-zh/）运行管线示例：</p><p><code>cargo run --bin tutorial3-pipeline</code></p><p>然后在 learn-wgpu-zh/target/debug/ 路径下你就能找到一个名为 <code>tutorial3-pipeline</code> 的可执行文件。</p></div><p>接下来，点击 <code>Start</code> 按钮，Xcode 就能运行我们指定的二进制文件了：</p><img src="'+h+'"><p>你应该能看三角形绘制程序正在运行，并且 Xcode 控制台的一些输出告诉我们已启用了 Metal 接口验证：</p><img src="'+c+'"><h2 id="查看实时-gpu-统计数据" tabindex="-1">查看实时 GPU 统计数据 <a class="header-anchor" href="#查看实时-gpu-统计数据" aria-label="Permalink to &quot;查看实时 GPU 统计数据&quot;">​</a></h2><p>仅需点击 <code>Start</code> 按钮运行我们要调试的程序，然后将 Xcode 左边栏切换至<strong>调试导航栏</strong>（Debug Navigator，通常 Xcode 会在调试项目启动时自动跳转到调试导航栏), 就能查看到实时的内存、CPU 占用及<strong>帧率</strong>（FPS）等，选中每一栏还可查看详情，以<strong>帧率</strong>栏为例，详情内还提供了 CPU 与 GPU 的每帧耗时，GPU <strong>顶点</strong>与<strong>片元</strong>运算单元的利用率等信息，方便我们诊断出程序的性能瓶颈之所在：</p><img src="'+g+'"><h2 id="gpu-帧捕获" tabindex="-1">GPU 帧捕获 <a class="header-anchor" href="#gpu-帧捕获" aria-label="Permalink to &quot;GPU 帧捕获&quot;">​</a></h2><p>要启动 Metal 的<strong>调试器</strong>（Debugger)，在点击 <code>Start</code> 按钮运行程序之后，需再点击 Xcode <strong>调试区</strong>（Debug Area）工具栏的 <code>Capture GPU Frame</code> 按钮（上面有个 Metal 图标的按钮）。 捕获一帧之后，我们就能够使用所有常规的 Metal 调试工具（例如 GPU 统计、着色器及缓冲区调试等）了：</p><img src="'+k+'"><h2 id="调试帧数据" tabindex="-1">调试帧数据 <a class="header-anchor" href="#调试帧数据" aria-label="Permalink to &quot;调试帧数据&quot;">​</a></h2><p>我们以 <a href="./../../beginner/tutorial6-uniforms/">Uniform 缓冲区</a> 教程的示例为例来调试 Uniform <strong>缓冲区</strong>中的数据: 捕获一帧之后，在<strong>调试导航栏</strong>选择 <code>Render Pass</code> 下的 <code>All Resources</code> 项，右边的列表里将会列出当前程序使用到的各种资源（纹理，缓冲区等）（左图），双击 <code>Camera Buffer</code> 就能格式化展示此缓冲区的数据了，同时数据展示区的下边会多出来一栏工具，方便我们切换数据的<strong>格式化</strong>类型及展示列数等（右图）。</p><div style="display:flex;"><div><img src="'+u+'" alt="Debug 导航栏"></div><div style="width:20px;"></div><div><img src="'+m+`" alt="Camera 缓冲区的数据"></div></div><div class="note"><h5 id="不知你有没有注意到" tabindex="-1">不知你有没有注意到 <a class="header-anchor" href="#不知你有没有注意到" aria-label="Permalink to &quot;不知你有没有注意到&quot;">​</a></h5><p>左侧的<strong>调试导航栏</strong>中的 Render Pass 及右侧资源列表里展示的名称（如，Camera Buffer）都是我们在代码里设置的 labal 参数：</p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> mut</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> render_pass </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> encoder</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">begin_render_pass</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wgpu</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RenderPassDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Render Pass&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ...</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> camera_buffer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> device</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create_buffer_init</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">wgpu</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">util</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">BufferInitDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    label</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Some</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Camera Buffer&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></div>`,36),y=[b];function _(P,v,f,F,A,x){return e(),a("div",null,y)}const w=s(E,[["render",_]]);export{D as __pageData,w as default};
