import{_ as e,c as a,o as i,a1 as n}from"./chunks/framework.Ozqerv3m.js";const u=JSON.parse('{"title":"Memory Layout in WGSL","description":"","frontmatter":{},"headers":[],"relativePath":"showcase/alignment.md","filePath":"showcase/alignment.md","lastUpdated":1757831631000}'),t={name:"showcase/alignment.md"};function l(r,s,p,h,o,d){return i(),a("div",null,[...s[0]||(s[0]=[n(`<h1 id="memory-layout-in-wgsl" tabindex="-1">Memory Layout in WGSL <a class="header-anchor" href="#memory-layout-in-wgsl" aria-label="Permalink to &quot;Memory Layout in WGSL&quot;">​</a></h1><div class="warn"><p>This page is currently being reworked. I want to understand the topics a bit better, but as 0.12 is out I want to release what I have for now.</p></div><h2 id="alignment-of-vertex-and-index-buffers" tabindex="-1">Alignment of vertex and index buffers <a class="header-anchor" href="#alignment-of-vertex-and-index-buffers" aria-label="Permalink to &quot;Alignment of vertex and index buffers&quot;">​</a></h2><p>Vertex buffers require defining a <code>VertexBufferLayout</code>, so the memory alignment is whatever you tell WebGPU it should be. This can be really convenient for keeping down memory usage on the GPU.</p><p>The Index Buffer uses the alignment of whatever primitive type you specify via the <code>IndexFormat</code> you pass into <code>RenderEncoder::set_index_buffer()</code>.</p><h2 id="alignment-of-uniform-and-storage-buffers" tabindex="-1">Alignment of Uniform and Storage buffers <a class="header-anchor" href="#alignment-of-uniform-and-storage-buffers" aria-label="Permalink to &quot;Alignment of Uniform and Storage buffers&quot;">​</a></h2><p>GPUs are designed to process thousands of pixels in parallel. In order to achieve this, some sacrifices had to be made. Graphics hardware likes to have all the bytes you intend on processing aligned by powers of 2. The exact specifics of why this is are beyond my level of knowledge, but it&#39;s important to know so that you can troubleshoot why your shaders aren&#39;t working.</p><p>Let&#39;s take a look at the following table:</p><hr><table tabindex="0"><thead><tr><th>Type</th><th>Alignment in Bytes</th><th>Size in Bytes</th></tr></thead><tbody><tr><td>scalar (i32, u32, f32)</td><td>4</td><td>4</td></tr><tr><td>vec2&lt;T&gt;</td><td>8</td><td>8</td></tr><tr><td>vec3&lt;T&gt;</td><td><strong>16</strong></td><td>12</td></tr><tr><td>vec4&lt;T&gt;</td><td>16</td><td>16</td></tr></tbody></table><p>You can see for <code>vec3</code> the alignment is the next power of 2 from the size, 16. This can catch beginners (and even veterans) off guard as it&#39;s not the most intuitive. This becomes especially important when we start laying out structs. Take the light struct from the <a href="./../intermediate/tutorial10-lighting/#seeing-the-light">lighting tutorial</a>:</p><p>You can see the full table of the alignments in section <a href="https://www.w3.org/TR/WGSL/#alignment-and-size" target="_blank" rel="noreferrer">4.3.7.1 of the WGSL spec</a></p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Light</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vec3f,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    color</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> vec3f,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>So what&#39;s the alignment of this struct? Your first guess would be that it&#39;s the sum of the alignments of the individual fields. That might make sense if we were in Rust-land, but in shader-land, it&#39;s a little more involved. The alignment for a given struct is given by the following equation:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>// S is the struct in question</span></span>
<span class="line"><span>// M is a member of the struct</span></span>
<span class="line"><span>AlignOf(S) = max(AlignOfMember(S, M1), ... , AlignOfMember(S, Mn))</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Basically, the alignment of the struct is the maximum of the alignments of the members of the struct. This means that:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>AlignOf(Light)</span></span>
<span class="line"><span>    = max(AlignOfMember(Light, position), AlignOfMember(Light, color))</span></span>
<span class="line"><span>    = max(16, 16)</span></span>
<span class="line"><span>    = 16</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>This is why the <code>LightUniform</code> has those padding fields. WGPU won&#39;t accept it if the data is not aligned correctly.</p><h2 id="how-to-deal-with-alignment-issues" tabindex="-1">How to deal with alignment issues <a class="header-anchor" href="#how-to-deal-with-alignment-issues" aria-label="Permalink to &quot;How to deal with alignment issues&quot;">​</a></h2><p>In general, 16 is the max alignment you&#39;ll see. In that case, you might think that we should be able to do something like the following:</p><div class="language-rust vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">rust</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[repr(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">C</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, align(16))]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">#[derive(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Debug</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Copy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Clone</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bytemuck</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Pod</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, bytemuck</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Zeroable</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">struct</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> LightUniform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    position</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    color</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f32</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>But this won&#39;t compile. The <a href="https://docs.rs/bytemuck/" target="_blank" rel="noreferrer">bytemuck crate</a> doesn&#39;t work with structs with implicit padding bytes. Rust can&#39;t guarantee that the memory between the fields has been initialized properly. This gave me an error when I tried it:</p><div class="language- vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>error[E0512]: cannot transmute between types of different sizes, or dependently-sized types</span></span>
<span class="line"><span>   --&gt; code/intermediate/tutorial10-lighting/src/main.rs:246:8</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>246 | struct LightUniform {</span></span>
<span class="line"><span>    |        ^^^^^^^^^^^^</span></span>
<span class="line"><span>    |</span></span>
<span class="line"><span>    = note: source type: \`LightUniform\` (256 bits)</span></span>
<span class="line"><span>    = note: target type: \`_::{closure#0}::TypeWithoutPadding\` (192 bits)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="additional-resources" tabindex="-1">Additional resources <a class="header-anchor" href="#additional-resources" aria-label="Permalink to &quot;Additional resources&quot;">​</a></h2><p>If you&#39;re looking for more information check out the <a href="https://gist.github.com/teoxoy/936891c16c2a3d1c3c5e7204ac6cd76c" target="_blank" rel="noreferrer">write-up</a> by @teoxoy.</p>`,25)])])}const g=e(t,[["render",l]]);export{u as __pageData,g as default};
