"use strict";(self.webpackChunklearn_wgpu_zh=self.webpackChunklearn_wgpu_zh||[]).push([[2859],{3150:(n,s,a)=>{a.r(s),a.d(s,{data:()=>t});const t=JSON.parse('{"key":"v-25d83dbe","path":"/showcase/compute/","title":"Compute Example: Tangents and Bitangents","lang":"zh-CN","frontmatter":{},"excerpt":"","headers":[{"level":2,"title":"Possible Improvements","slug":"possible-improvements","link":"#possible-improvements","children":[]},{"level":2,"title":"Results","slug":"results","link":"#results","children":[]}],"git":{"updatedTime":1665022431000},"filePathRelative":"showcase/compute/README.md"}')},5372:(n,s,a)=>{a.r(s),a.d(s,{default:()=>k});var t=a(6252);const e=a.p+"assets/img/corruption.4d0cd631.png",p=a.p+"assets/img/black_triangles.5867e2e9.png",o=a.p+"assets/img/render_doc_output.d2409f81.png",c=a.p+"assets/img/results.59325691.png",i=(0,t._)("h1",{id:"compute-example-tangents-and-bitangents",tabindex:"-1"},[(0,t._)("a",{class:"header-anchor",href:"#compute-example-tangents-and-bitangents","aria-hidden":"true"},"#"),(0,t.Uk)(" Compute Example: Tangents and Bitangents")],-1),l=(0,t._)("code",null,"ModelVertex",-1),u={href:"/intermediate/tutorial11-normals/",target:"_blank",rel:"noopener noreferrer"},r=(0,t.uE)('<div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token attribute attr-name">#[repr(C)]</span>\n<span class="token attribute attr-name">#[derive(Copy, Clone, Debug, bytemuck::Pod, bytemuck::Zeroable)]</span>\n<span class="token keyword">pub</span> <span class="token keyword">struct</span> <span class="token type-definition class-name">ModelVertex</span> <span class="token punctuation">{</span>\n    position<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    tex_coords<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">;</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    normal<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    tangent<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n    bitangent<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token keyword">f32</span><span class="token punctuation">;</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>This structure works perfectly fine when used as a vertex buffer. Using it as a storage buffer proved less convenient. My previous code used a GLSL struct similar to my <code>ModelVertex</code>.</p><div class="language-glsl ext-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">struct</span> <span class="token class-name">ModelVertex</span> <span class="token punctuation">{</span>\n    <span class="token keyword">vec3</span> position<span class="token punctuation">;</span>\n    <span class="token keyword">vec2</span> tex_coords<span class="token punctuation">;</span>\n    <span class="token keyword">vec3</span> normal<span class="token punctuation">;</span>\n    <span class="token keyword">vec3</span> tangent<span class="token punctuation">;</span>\n    <span class="token keyword">vec3</span> bitangent<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>At first glance, this seems just fine, but OpenGL experts would likely see a problem with the structure. Our fields aren&#39;t aligned properly to support the <code>std430</code> alignment that storage buffers require. I won&#39;t get into detail but you can check out the <a href="../alignment">alignment showcase</a> if you want to know more. To summarize, the <code>vec2</code> for the <code>tex_coords</code> was messing up the byte alignment, corrupting the vertex data resulting in the following:</p><p><img src="'+e+'" alt="./corruption.png"></p><p>I could have fixed this by adding a padding field after <code>tex_coords</code> on the Rust side, but that would require modifying the <code>VertexBufferLayout</code>. I ended up solving this problem by using the components of the vectors directly which resulted in a struct like this:</p><div class="language-glsl ext-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">struct</span> <span class="token class-name">ModelVertex</span> <span class="token punctuation">{</span>\n    <span class="token keyword">float</span> x<span class="token punctuation">;</span> <span class="token keyword">float</span> y<span class="token punctuation">;</span> <span class="token keyword">float</span> z<span class="token punctuation">;</span>\n    <span class="token keyword">float</span> uv<span class="token punctuation">;</span> <span class="token keyword">float</span> uw<span class="token punctuation">;</span>\n    <span class="token keyword">float</span> nx<span class="token punctuation">;</span> <span class="token keyword">float</span> ny<span class="token punctuation">;</span> <span class="token keyword">float</span> nz<span class="token punctuation">;</span>\n    <span class="token keyword">float</span> tx<span class="token punctuation">;</span> <span class="token keyword">float</span> ty<span class="token punctuation">;</span> <span class="token keyword">float</span> tz<span class="token punctuation">;</span>\n    <span class="token keyword">float</span> bx<span class="token punctuation">;</span> <span class="token keyword">float</span> by<span class="token punctuation">;</span> <span class="token keyword">float</span> bz<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>Since <code>std430</code> will use the alignment of the largest element of the struct, using all floats means the struct will be aligned to 4 bytes. This is alignment matches what <code>ModelVertex</code> uses in Rust. This was kind of a pain to work with, but it fixed the corruption issue.</p><p>The second problem required me to rethink how I was computing the tangent and bitangent. The previous algorithm I was using only computed the tangent and bitangent for each triangle and set all the vertices in that triangle to use the same tangent and bitangent. While this is fine in a single-threaded context, the code breaks down when trying to compute the triangles in parallel. The reason is that multiple triangles can share the same vertices. This means that when we go to save the resulting tangents, we inevitably end up trying to write to the same vertex from multiple different threads which is a big no no. You can see the issue with this method below:</p><p><img src="'+p+'" alt="./black_triangles.png"></p><p>Those black triangles were the result of multiple GPU threads trying to modify the same vertices. Looking at the data in Render Doc I could see that the tangents and bitangents were garbage numbers such as <code>NaN</code>.</p><p><img src="'+o+'" alt="./render_doc_output.png"></p><p>While on the CPU we could introduce a synchronization primitive such as a <code>Mutex</code> to fix this issue, AFAIK there isn&#39;t really such a thing on the GPU. Instead, I decided to swap my code to work with each vertex individually. There are some hurdles with that, but those will be easier to explain in code. Let&#39;s start with the <code>main</code> function.</p><div class="language-glsl ext-glsl line-numbers-mode"><pre class="language-glsl"><code><span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">uint</span> vertexIndex <span class="token operator">=</span> gl_GlobalInvocationID<span class="token punctuation">.</span>x<span class="token punctuation">;</span>\n    ModelVertex result <span class="token operator">=</span> <span class="token function">calcTangentBitangent</span><span class="token punctuation">(</span>vertexIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    dstVertices<span class="token punctuation">[</span>vertexIndex<span class="token punctuation">]</span> <span class="token operator">=</span> result<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We use the <code>gl_GlobalInvocationID.x</code> to get the index of the vertex we want to compute the tangents for. I opted to put the actual calculation into its own method. Let&#39;s take a look at that.</p><div class="language-glsl ext-glsl line-numbers-mode"><pre class="language-glsl"><code>ModelVertex <span class="token function">calcTangentBitangent</span><span class="token punctuation">(</span><span class="token keyword">uint</span> vertexIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    ModelVertex v <span class="token operator">=</span> srcVertices<span class="token punctuation">[</span>vertexIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n    <span class="token keyword">vec3</span> tangent <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">vec3</span> bitangent <span class="token operator">=</span> <span class="token keyword">vec3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">uint</span> trianglesIncluded <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// Find the triangles that use v</span>\n    <span class="token comment">//  * Loop over every triangle (i + 3)</span>\n    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">uint</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> numIndices<span class="token punctuation">;</span> i <span class="token operator">+=</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">uint</span> index0 <span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">uint</span> index1 <span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n        <span class="token keyword">uint</span> index2 <span class="token operator">=</span> indices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n        <span class="token comment">// Only perform the calculation if one of the indices</span>\n        <span class="token comment">// matches our vertexIndex</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>index0 <span class="token operator">==</span> vertexIndex <span class="token operator">||</span> index1 <span class="token operator">==</span> vertexIndex <span class="token operator">||</span> index2 <span class="token operator">==</span> vertexIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            ModelVertex v0 <span class="token operator">=</span> srcVertices<span class="token punctuation">[</span>index0<span class="token punctuation">]</span><span class="token punctuation">;</span>\n            ModelVertex v1 <span class="token operator">=</span> srcVertices<span class="token punctuation">[</span>index1<span class="token punctuation">]</span><span class="token punctuation">;</span>\n            ModelVertex v2 <span class="token operator">=</span> srcVertices<span class="token punctuation">[</span>index2<span class="token punctuation">]</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">vec3</span> pos0 <span class="token operator">=</span> <span class="token function">getPos</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">vec3</span> pos1 <span class="token operator">=</span> <span class="token function">getPos</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">vec3</span> pos2 <span class="token operator">=</span> <span class="token function">getPos</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">vec2</span> uv0 <span class="token operator">=</span> <span class="token function">getUV</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">vec2</span> uv1 <span class="token operator">=</span> <span class="token function">getUV</span><span class="token punctuation">(</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token keyword">vec2</span> uv2 <span class="token operator">=</span> <span class="token function">getUV</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n            <span class="token keyword">vec3</span> delta_pos1 <span class="token operator">=</span> pos1 <span class="token operator">-</span> pos0<span class="token punctuation">;</span>\n            <span class="token keyword">vec3</span> delta_pos2 <span class="token operator">=</span> pos2 <span class="token operator">-</span> pos0<span class="token punctuation">;</span>\n\n            <span class="token keyword">vec2</span> delta_uv1 <span class="token operator">=</span> uv1 <span class="token operator">-</span> uv0<span class="token punctuation">;</span>\n            <span class="token keyword">vec2</span> delta_uv2 <span class="token operator">=</span> uv2 <span class="token operator">-</span> uv0<span class="token punctuation">;</span>\n\n            <span class="token keyword">float</span> r <span class="token operator">=</span> <span class="token number">1.0</span> <span class="token operator">/</span> <span class="token punctuation">(</span>delta_uv1<span class="token punctuation">.</span>x <span class="token operator">*</span> delta_uv2<span class="token punctuation">.</span>y <span class="token operator">-</span> delta_uv1<span class="token punctuation">.</span>y <span class="token operator">*</span> delta_uv2<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            tangent <span class="token operator">+=</span> <span class="token punctuation">(</span>delta_pos1 <span class="token operator">*</span> delta_uv2<span class="token punctuation">.</span>y <span class="token operator">-</span> delta_pos2 <span class="token operator">*</span> delta_uv1<span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">*</span> r<span class="token punctuation">;</span>\n            bitangent <span class="token operator">+=</span> <span class="token punctuation">(</span>delta_pos2 <span class="token operator">*</span> delta_uv1<span class="token punctuation">.</span>x <span class="token operator">-</span> delta_pos1 <span class="token operator">*</span> delta_uv2<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> r<span class="token punctuation">;</span> \n            trianglesIncluded <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n        \n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// Average the tangent and bitangents</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>trianglesIncluded <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        tangent <span class="token operator">/=</span> trianglesIncluded<span class="token punctuation">;</span>\n        bitangent <span class="token operator">/=</span> trianglesIncluded<span class="token punctuation">;</span>\n        tangent <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>tangent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n        bitangent <span class="token operator">=</span> <span class="token function">normalize</span><span class="token punctuation">(</span>bitangent<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// Save the results</span>\n    v<span class="token punctuation">.</span>tx <span class="token operator">=</span> tangent<span class="token punctuation">.</span>x<span class="token punctuation">;</span>\n    v<span class="token punctuation">.</span>ty <span class="token operator">=</span> tangent<span class="token punctuation">.</span>y<span class="token punctuation">;</span>\n    v<span class="token punctuation">.</span>tz <span class="token operator">=</span> tangent<span class="token punctuation">.</span>z<span class="token punctuation">;</span>\n    v<span class="token punctuation">.</span>bx <span class="token operator">=</span> bitangent<span class="token punctuation">.</span>x<span class="token punctuation">;</span>\n    v<span class="token punctuation">.</span>by <span class="token operator">=</span> bitangent<span class="token punctuation">.</span>y<span class="token punctuation">;</span>\n    v<span class="token punctuation">.</span>bz <span class="token operator">=</span> bitangent<span class="token punctuation">.</span>z<span class="token punctuation">;</span>\n\n    <span class="token keyword">return</span> v<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="possible-improvements" tabindex="-1"><a class="header-anchor" href="#possible-improvements" aria-hidden="true">#</a> Possible Improvements</h2><p>Looping over every triangle for every vertex is likely raising some red flags for some of you. In a single-threaded context, this algorithm would end up being O(N*M). As we are utilizing the high number of threads available to our GPU, this is less of an issue, but it still means our GPU is burning more cycles than it needs to.</p><p>One way I came up with to possibly improve performance is to store the index of each triangle in a hash map like structure with the vertex index as keys. Here&#39;s some pseudo code:</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">for</span> t <span class="token keyword">in</span> <span class="token number">0</span><span class="token punctuation">..</span>indices<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">3</span> <span class="token punctuation">{</span>\n    triangle_map<span class="token punctuation">[</span>indices<span class="token punctuation">[</span>t <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    triangle_map<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>indices<span class="token punctuation">[</span>t <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    triangle_map<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">(</span>indices<span class="token punctuation">[</span>t <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>We&#39;d then need to flatten this structure to pass it to the GPU. We&#39;d also need a second array to index the first.</p><div class="language-rust ext-rs line-numbers-mode"><pre class="language-rust"><code><span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token punctuation">(</span>_v<span class="token punctuation">,</span> t_list<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">in</span> triangle_map<span class="token punctuation">.</span><span class="token function">iter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">enumerate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    triangle_map_indices<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token class-name">TriangleMapIndex</span> <span class="token punctuation">{</span> \n        start<span class="token punctuation">:</span> i<span class="token punctuation">,</span>\n        len<span class="token punctuation">:</span> t_list<span class="token punctuation">.</span><span class="token function">len</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    flat_triangle_map<span class="token punctuation">.</span><span class="token function">extend</span><span class="token punctuation">(</span>t_list<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>I ultimately decided against this method as it was more complicated, and I haven&#39;t had time to benchmark it to see if it&#39;s faster than the simple method.</p><h2 id="results" tabindex="-1"><a class="header-anchor" href="#results" aria-hidden="true">#</a> Results</h2><p>The tangents and bitangents are now getting calculated correctly and on the GPU!</p><p><img src="'+c+'" alt="./results.png"></p>',26),d={},k=(0,a(3744).Z)(d,[["render",function(n,s){const a=(0,t.up)("ExternalLinkIcon"),e=(0,t.up)("AutoGithubLink");return(0,t.wg)(),(0,t.iD)("div",null,[i,(0,t._)("p",null,[(0,t.Uk)("This proved more difficult than I anticipated. The first problem I encountered was some vertex data corruption due to the shader reading my vertex data incorrectly. I was using the "),l,(0,t.Uk)(" struct I used in the "),(0,t._)("a",u,[(0,t.Uk)("normal mapping tutorial"),(0,t.Wm)(a)]),(0,t.Uk)(".")]),r,(0,t.Wm)(e)])}]])}}]);